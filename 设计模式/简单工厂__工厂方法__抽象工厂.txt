/**
* @defgroup 设计模式
* @{
*/


/**
@verbatim
1、考虑用户（这个用户可能是自己也可能是其他的程序员）的需求：给出一个汽车类型，获取一个汽车对象。怎么办？
2、使用简单工厂。如下：
	创建抽象类ICar，具体类Sedan（轿车）和具体类SportCar继承ICar。
	创建简单工厂类，根据汽车类型（使用switch），创建汽车对象返回。
3、用户需求变化，要求给出SUV类型，获取SUV汽车对象。怎么办？
4、增加具体类SUV，继承ICar。在简单工厂类增加switch的分支。但是这存在问题：
	a、具体类SUV满足开闭原则，而简单工厂类不满足开闭原则，要修改简单工厂类的代码，增加分支。
	b、同时简单工厂类是个上帝类，需要返回一切需要的汽车对象。
	怎么办？
5、使用工厂方法。如下：
	创建抽象工厂IFactory，以及具体工厂类SedanFactory和SportCarFactory。
	当用户需要SUV的时候，增加一个工厂类SUVFactory，满足开闭原则。
6、用户需求变化，期望获取一个品牌的轿车和跑车，比如给出奔驰，期望获取奔驰轿车和奔驰跑车。
	如果用户还是使用工厂方法，用户可能会用SedanFactory获取奔驰轿车，但是用SportCarFactory获取宝马跑车。
	这就导致了使用windows的锤子去敲linux的钉子，不匹配。要把用户想象的就是这么傻。怎么解决这个问题？
7、这就涉及到产品族的概念，解决办法是使用抽象工厂。如下：
	创建抽象工厂IFactory，以及具体工厂类BenZFactory和BmwFactory。
	BenZFactory有两个方法，分别负责生产奔驰轿车和奔驰跑车，
	BmwFactory有两个方法，分别负责生产宝马轿车和宝马跑车。
	这样，再傻的用户也不会出错，生产出来的轿车和跑车是匹配的，也就是同一品牌。
@endverbatim
@see
*/
简单工厂__工厂方法__抽象工厂;


/** @} */