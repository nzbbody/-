/**
* @defgroup STL
* @{
*/

/**
* @defgroup Effective__STL
* @{
*/

/**
@verbatim
1、考虑下面的需求，对于vec开始的时候有1000个元素，后来只有10个元素，那么vec的capacity至少还是1000，
	后面的990个内存单元，没有使用，但是还被vec霸占着。如何释放这些内存呢？
2、我们知道，vector进行copy构造的时候，根据rhs 的size进行分配内存。因此，我们可以建立一个临时对象，然后交换一下就可以了。如下：
	vector<int>(vec).swap(vec);
	vector<int>(vec) 是个临时对象，可认为capacity为10，而vec的capacity为1000，二者交换后，vec的capacity为10，临时对象析构。
3、这里需要注意两点：
	a、临时对象的capacity有可能还是大于10，不能保证容量最小，而是尽量小。
	b、对于vector 的swap方法，内部实现只是交换了彼此的begin指针和end指针，并没有交换内容。
	这个很好理解，对于资源管理类，也就是内含指针的类，交换的时候，只需要交换彼此的指针就好了。
	举个例子：甲住501，乙住502，现在甲乙想换房子。只要换一下钥匙就好了，如果去把房间里的家电家具换一下，方法也太笨了。
4、考虑一个特殊情况，我想清空一个容器，并释放所有内存，该怎么办？
	首先，clear方法是不行的，因为它只是把元素清空，内存还被霸占着。由上面的分析，很容易想到，拿一个空容器与当前容器交换一下，就行了。
	也就是：vector<int>().swap(vec);
@endverbatim
*/
【S17】使用swap技巧除去多余的容量;


/** @} */

/** @} */
