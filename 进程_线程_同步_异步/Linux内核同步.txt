/**
* @defgroup 进程_线程_同步_异步
* @{
*/

/**
@verbatim
1、原子操作，是其它同步方法的基础。
2、自旋锁，线程试图获取一个已经被别人持有的自旋锁，当前线程处于忙等待，占用cpu资源。
3、读写自旋锁，根据通用性和针对性的特点，普通自旋锁在特定场景下的表现会退化。
	因此，提供了读写自旋锁，读锁可以加读锁，不能加写锁，写锁不能加任何锁。
4、需要注意的几项：
	普通自旋锁是不能递归的。读锁可以递归，写锁也不能递归。
	表面上锁的是代码，实际上锁的是共享数据。
	使用读写锁的时候，需要注意，读锁可以加读锁，多个线程都占用读锁，必须所有的线程都释放，才能加上写锁，
	这往往会导致写锁长时间处于饥饿状态。
5、自旋锁存在的问题，线程试图获取一个已经被别人持有的自旋锁，当前线程处于忙等待，占用cpu资源。怎么解决这个问题？
	使用信号量，信号量是一种睡眠锁。一个任务试图获取被别人占有的信号量，信号量会将其推进一个等待队列，让其睡眠，
	当请求的信号量被释放，处于等待队列的任务被唤醒，并获得信号量。
6、需要注意的是，信号量是一种睡眠锁，但它本身也会带有开销，上下文切换，被阻塞的线程要换出换入，
	也即是说让其睡眠并唤醒它，花费一定的开销。如果每个线程锁的时间很短，一般使用自旋锁，忙等待的时间也很短。
	如果锁的时间长，使用信号量。
7、相比自旋锁，信号量还有更广泛的用处，使用PV操作不仅能保护共享资源，还能够控制同时访问的数量，还能够控制访问顺序。
	对于锁，是谁加锁谁释放，而信号量可以再不同线程之间PV操作。
8、考虑信号量的一种特殊使用场景，可以睡眠的互斥锁。创建的信号量容量为1，可用数量为1，也就是允许同时访问的数量也就是1。
	这就是互斥体，互斥体加锁可以认为是P操作，再V操作。
@endverbatim
*/
Linux内核同步;

/** @} */