/**
* @defgroup 程序员修炼
* @{
*/

/**
@verbatim
1、有时候会遇到莫名其妙的问题，解决起来完全没有思路，不知道从哪里下手，这个时候怎么办？
2、采用排除法，把可能导致问题的代码注释掉，看看问题是否还存在。
	如果问题不存在，就说明这部分代码有问题。通过这种方式逐渐缩小范围，然后再仔细分析。
@endverbatim
*/
解决问题的思路和办法;

/**
@verbatim
1、有时候搭建一个测试环境，需要很长时间，在windows下调试比较麻烦。
2、在具备条件的时候，可以把服务切换到本地进行调试。
3、如果不能切换到本地，就必须直接修改代码，编译出来，放到linux主机上进行调试。
	使用gdb调试比较麻烦，特别是基于多线程的消息机制，更难调试。
4、这个时候，就依赖最重要的工具，日志。写日志需要很多技巧，如下：
	a、在重要的分支前，打印判断条件的取值
	b、方法的返回值重要，多个地方调用，在方法返回之前打印出来
	c、没有性能问题，日志级别使用Info
	d、存在性能问题（也就是频繁地执行打印），但是取值又需要观察，使用Debug，调试的时候开启Debug，现场环境关闭Debug
@endverbatim
*/
如何快速完成功能;

/**
@verbatim
1、首先分析内存泄露的特点，是缓慢式的，还是脉冲式的。
	缓慢式的：内存增长比较频繁，但是每次增长一点。比如每过10秒增长1M
	脉冲式的：平时内存消耗不变化，突然某个时间点内存增长很多（比如100M），并且经过长时间，内存消耗降不下来。
2、如果内存增长比较频繁，而且每次增长很多，往往比较好定位。
3、缓慢式的内存泄露，场景往往是：频繁执行new操作，每次分配一点内存，没有释放，导致内存一点一点增长。
4、脉冲式的内存泄露，场景往往是：经过长时间运行，走到某个分支，在这个分支new出一大块内存，没有释放。
	又经过一段很长的时间（或者某个外部条件触发），再次走到这个分支。
5、内存泄露的根本原因是：new出来的动态内存，没有释放。因此需要重点关注代码中的指针，new操作，delete操作。
6、开始的时候，定位内存泄露往往没有头绪。最好使用排除法。
7、排除法的步骤是：注释掉有嫌疑的代码，观察是否有内存泄露。
	如果还有内存泄露，说明这块代码没有问题。
	如果没有了内存泄露，说明就是这块代码的问题，然后采用同样的方法，逐步缩小代码的范围。
@endverbatim
*/
如何定位内存泄露;


/**
@verbatim
1、知识丰富，并不意味着能当一个好老师。
2、给非专业人士讲解概念的时候，按照水平高低，分为3个档次、
3、三流老师：讲一大堆细节，列举条例，追求大而全，不重视逻辑和因果关系，让听者更糊涂。
4、二流老师：善用比喻，讲述幽默，吸引人。
5、一流老师：来龙去脉，一气贯通，逻辑缜密，当头一棒。
6、一流老师的讲述过程可以抽象为：目的--->产生什么问题--->解决思路，为什么要沿着这个思路？
	因为本质上，人类的所有知识都是为了解决问题而存在的。
7、以足球越位为例来说明，很多人搞不清楚怎么回事。按照上面的思路来讲解。
8、目的：足球运动的目的是把足球踢进对方的球门。
9、产生什么问题：为了进球，最有效的办法就是：前锋可劲往前钻，最好站在对方门前，后卫可劲把球传到对方门前，
	这样就有很大机会，而且很容易进球。大家都这么踢球，就没有什么意思了。
10、解决思路：怎么解决上面的问题？
	为了防止这种猥琐的踢球方法，需要制定规则：当队友向前给你传球的时候，你不能站在特别前面。但是什么叫做特别前面呢？
	总得有个标准，标准就是：当队友向前给你传球的时候，除了对方守门员意外，你前面至少存在一名对方的防守球员。
	这就是越位规则。
@endverbatim
*/
如何当一个好老师;

/**
@verbatim
1、有时候日志文件太大，打开很慢，可以使用grep对日志文件操作，过滤出自己感兴趣的内容。如下：
	more 2016-12-9.log|grep -n "Data For File\[" > 111.log
	注意：-n显示行数，中括号[需要转义
2、windows下使用findstr，如下：
	findstr /i "setRecordId_ForSlaveChannel" 2016-12-7.log >111.txt
@endverbatim
*/
读取日志的技巧;


/** @} */
