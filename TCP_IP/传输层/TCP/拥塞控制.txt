/**
* @defgroup TCP
* @{
*/

/**
* @defgroup 拥塞控制
* @{
*/

/**
@verbatim
1、考虑下面的场景，tcp传输中出现拥塞。因此tcp超时重传，越重传越拥塞，越拥塞越重传，导致恶性循环。
	网络传输的原则是：尽量多地传输数据。如果不拥塞，就增加数据，一旦出现拥塞。就减少发送数量。
2、如何解决这个问题？
	发送端预设值一个大小值，表示当前网络的拥塞程度，这就是拥塞窗口。
	这个窗口（和发送窗口）影响发送端发送数据的数量，当前不拥塞，加大拥塞窗口，当前拥塞，减少拥塞窗口。
3、刚开始不知道网络的拥塞程度，怎么办呢？
	先假设一个拥塞窗口（慢启动门限），然后采用试探的方式。发1个试试，不拥塞，那就发2个试试，还不拥塞，那就发4个试试。。。
	通过这样的方式，发现合适的拥塞窗口。这就是慢启动算法，需要注意的是慢启动算法并不慢，因为指数增长，很快就上来了。
4、当到达慢启动门限时，这个时候就不能指数增长了。而应该使用线性增长，每经过一个往返时间RTT，拥塞窗口加1。
	一旦出现拥塞，设为原来的一半。
	也就是说，当接近网络吞吐量的时候，一点一点增加。拥塞了，并不是重新慢启动进行试探，而是减为原来的一半（再一点一点增加）。
	相对于慢启动，这就是快恢复。
5、考虑另外一种场景：
	发送端发送了m1，m2，m3，m4四个报文，而接收端收到了m1，m2，m4，没有收到m3.
	但是发送端并不知道，还会接着发送m5，m6，m7... 
	这种情况下，m3会重发，并且m3之后的m4，m5，m6，m7也要求重发。因此，在没有收到m3的情况下，发送m5，m6，m7是没有意义的。
	怎么解决这个问题？
6、接收端回复说，我才收到m2，我才收到m2，我才收到m2，重要的事说三遍。让发送端赶紧发m3，于是发送端先发m3，这就是快速重传。
@endverbatim
*/
拥塞窗口;


/**
@verbatim
1、发送的数据都要加上协议头部，协议头部占用一部分带宽。为了有效利用带宽，每次发送的数据都应该尽量大，这样净负荷比较高。
	考虑极端的情况，每次发送一个字节，头部是40个字节，净负荷才40分之1，怎么解决这个问题？
2、Nagle算法就是为了解决这个问题：当网络上存在一个没有被确认的小段，当前的小段不发送。
3、怎么理解这句话？
	a、网络上存在没有被确认的大段，不需要考虑，因为大段本身就需要较长的RTT（Round Trip Time）。
	b、网络上所有的段都被确认了，可以直接发送。
	c、当前是一个大段，可以直接发送，因为净负荷已经比较高了。
	d、当前是一个fin包，立即发送
	e、当前是一个小段，不发送，再积累一些，然后一起发送。
@endverbatim
*/
Nagle算法;


/** @} */

/** @} */

