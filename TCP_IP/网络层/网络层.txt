/**
* @defgroup TCP_IP
* @{
*/


/**
* @defgroup 网络层
* @{
*/

/**
@verbatim
127.x.x.x
1、127.x.x.x是环回接口（Loopback interface），包括从127.0.0.1到127.255.255.254
	ping 127.0.0.1到127.255.255.254结果都是一样的，它们是等价的。
2、环回接口的原理是：
	正常的数据包发送接收流程：发送数据包从传输层到网络IP层，再到数据链路层，再到物理层，发出去。
	然后从物理层收到数据包，传给数据链路层，再传给Ip层，放入IP的接收队列中。
	而向环回接口（也就是127.x.x.x）发送数据包，在IP层短路，反正是发给自己，不再向下发给数据链路层。
	直接放入IP的接收队列中，然后接收数据包就是，从IP的接收队列中读取出来。
3、也就是说，环回接口发送数据包，在IP层短路，直接放入IP的接收队列中，接收数据包从IP的接收队列中取出来。
4、除了127.x.x.x ，还有两种情况，数据包的发送直接放入IP的接收队列中。
	a、UDP的广播和多播，因为广播和多播的定义包含主机本身，对于广播和多播，数据包复制一份放入IP的接受队列中，
		同时向下发给数据链路层，广播或者多播出去。
	b、目的地址是本机地址，比如本机地址是10.36.65.80，向10.36.65.80发送数据包，也在IP层短路，直接放入IP的接受队列中。
5、对于环回接口，在Linux上使用tcpdump可以抓到相应的包，在Windows上使用wireshark抓不到，为什么？
	这是因为Linux系统的TCP/IP栈了实现环回接口，而Windows系统的TCP/IP栈没有实现环回接口。
	怎么解决在Windows上使用wireshark抓不到数据包？
6、在Windows上使用wireshark抓不到数据包，是因为直接放入IP的接收队列中，根本就不经过网络。
	对于目标地址127.x.x.x，肯定不能抓到。
	而对于目标地址10.36.65.80，IP层会有一个判断过程，到达10.36.65.80经过什么路线。
	如果没有设置，就是本机地址，直接放入IP的接收队列中。
	因此，解决办法就是，到达10.36.65.80强制指定一条路线，经过路由器。设置如下：
	route add 10.36.65.80 mask 255.255.255.255 10.36.65.1 metric 1
	（注意：对于127.0.0.2使用这种方式设置，也是抓不到包的，因为环回接口直接放入IP的接收队列中，没有判断过程）
	这样的话，IP层就必须按照指定的路线将数据包向下发出去。
	流程是：数据包发出去，经过路由器，再转发回来。也就是说，在网络上绕一圈。
	这样就能抓到数据包了。
@endverbatim

@verbatim
0.0.0.0
1、解决什么问题？
	主机可能有多个IP地址（含有多个网卡的情况），IP地址可能会发生变化。
	客户端可能在远端，通过主机IP地址10.36.65.80来连接，也有可能在本地，通过环回接口127.0.0.1来连接。
2、那么问题来了？
	当前应用程序在哪个IP地址监听呢？
3、如果固定下来IP地址，就会导致其他的情况连接失败。
	0.0.0.0就是为了解决这个问题，表示监听主机的所有IP地址（不固定是哪一个），以上情况的连接都能收到。
4、同一个端口可以监听多次，只要使用的IP地址不同，比如，当前主机为10.36.65.80，可以监听
	10.36.65.80:8080
	127.0.0.1:8080
	0.0.0.0:8080
@endverbatim

@verbatim
私网地址
1、私网地址如下：
	10.0.0.0/8:		10.0.0.0～10.255.255.255		A类私网地址
	172.16.0.0/12:	172.16.0.0～172.31.255.255		B类私网地址
	192.168.0.0/16:	192.168.0.0～192.168.255.255	C类私网地址
2、特别注意：私网的ABC类地址，与互联网的ABC类地址，子网掩码表达的意思不一样。
	互联网的ABC类地址子网掩码分别是8,16,24，而私网的ABC类地址子网掩码分别是8,12,16，二者不一致。
	它们的子网掩码不存在必然的关系。可以这样理解：
	互联网的ABC类地址是分别从0.0.0.0-255.255.255.255中挖出一块空间，为了区分是哪一类地址，它们的前缀不一样。
	对于挖出来的一块空间（前缀标识），使用不同的子网掩码，标识网络号和主机号。
	而私网地址，从互联网的ABC类地址空间中，分别挖出一块，专门作为私网地址，对应的就是ABC类中的私网地址。
3、另外，169.254.x.x 则主要是分配给DHCP服务使用的
@endverbatim

@verbatim
广播地址
1、255.255.255.255是全局广播地址
2、主机号全部为1的地址是子网广播地址，如：192.168.1.255
3、主机号全部为0的地址是子网的网络地址，代表子网本身，而不是一台主机，如：192.168.1.0
@endverbatim
*/
各种Ip地址;

/**
@verbatim
1、IP选路原理
	a、搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。
		如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。
	b、搜索路由表，寻找能与目的网络号相匹配的表目。
		如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。
		目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。
	c、搜索路由表，寻找标为“默认（ d e f a u l t）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。
	d、如果上面这些步骤都没有成功，那么该数据报就不能被传送。
		如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。
	注意：可以认为查找的顺序是从小范围到大范围。
2、对于一个给定的路由器，可以打印出五种不同的标志（ f l a g）：
	U 该路由可以使用
	G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的
	H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。
		如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址，一个网络号，或者网络号与子网号的组合
	D 该路由是由重定向报文创建的
	M 该路由已被重定向报文修改
3、注意：
	G是区分下一跳的，没有G是直接路由，有G是间接路由。直接路由说明下一跳就是目标，分组中包含目标IP地址和目标mac地址。
	间接路由说明下一跳是路由器，分组中包含最终的目标IP地址和下一跳路由器的mac地址。
	H是区分目标地址完整程度的，没有H说明目标是一个网络，有H说明目标是一个主机。
	G和H二者是不互斥的，可以各种组合。
	默认路由，全部为0，也就是0.0.0.0，这个路由将匹配剩余所有的包，能帮助减少路由条目。
4、在不同的协议层，对于传输的数据，叫法不一样。
	在链路层以太网		称为帧
	在网络层IP			称为IP数据报
	在传输层UDP			称为UDP数据报
	在传输层TCP			称为TCP报文段
	计算机网络不能一次性传输任意长的数据，需要把数据分割成小块，进行传输，这些小块称为分组。
@endverbatim
*/
IP选路;

/**
@verbatim
1、一个网络内的设备通过交换机连接在一起，直接通信，交换机在内存中直接把数据发给目的设备
	（注意：集线器是转发给所有的设备，因此交换机更有效率）
2、交换机只能对同一个网络的数据包进行转发，当与另一个网络进行通信的时候，怎么办？
3、需要一个路由器。这个路由器一般有两个网卡，一个网卡连接当前网络的交换机，另一个网卡连接另一个网络的交换机。
	在路由器上根据Ip地址设置网卡的转发功能，这就实现了一个网络到另一个网络的通信。
4、要完成当前网络到另一个网络的通信，还需要对当前网络的设备设置路由，也就是到达另一个网络经过哪个路由器，
	把默认网关设置为当前网络上的路由器，注意：设置的路由必须是可以直接通信的。
	对于同一个网络的通信，不需要设置路由。因为一个网络接口，也就是ip地址，会根据子网掩码自动产生一个路由项。
5、在两个网络中间搭建一个路由器，就可以实现两个网络的通信。通过这种方式，理论上可以实现任意两个网络的通信。
	加上一个路由器就是直接的通信，加上多个路由器就是间接的通信。
	当然路由器也可以提供3个或者以上的网卡，分别连接多个网络，根据Ip地址设置网卡的转发功能，实现多个网络的通信。
6、路由功能可以在硬件实现，比如思科，华为，也可以在软件实现，Linux内核就提供路由的功能。
	Linux内核通过route命令添加路由，用于数据包的转发。另外，还提供NAT的功能，使用iptables命令，用于数据包的转换功能。
@endverbatim
*/
路由器有关;


/**
@verbatim
1、路由打印如下：
	[root@localhost lib]# route -n
	Kernel IP routing table
	Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
	10.22.4.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1
	169.254.0.0     0.0.0.0         255.255.0.0     U     0      0        0 eth1
	0.0.0.0         10.22.4.1       0.0.0.0         UG    0      0        0 eth1
2、前面三列很好理解，Genmask是子网掩码。
	IP选路的策略是：先匹配主机，再匹配网络；先找小范围，再找大范围。
3、Flags的含义如下：
	U 该路由可以使用
	G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的
	H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。
		如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址，一个网络号，或者网络号与子网号的组合
	D 该路由是由重定向报文创建的
	M 该路由已被重定向报文修改
	注意：D在什么情况下会产生？
	主机向路由器A，发送消息，路由器A通过ICMP重定向差错，告诉主机存在一个更好的路由B，主机在路由表增加一个路由记录B。
4、Metric的含义：
	表示一组参数，包括带宽，跳数，负载等，可以理解为路由成本，值越小，成本越低，优先选择这条路由。
5、Ref的含义：
	正在使用该路由的进程个数。特别注意，使用route -n看不到结果，需要使用route -nC
	比如，新建一个telnet连接，可以看到Ref的值增加1，如下：
	[root@localhost lib]# route -nC|grep -v lo
	Kernel IP routing cache
	Source          Destination     Gateway         Flags Metric Ref    Use Iface
	10.22.4.151     10.36.65.80     10.22.4.1             0      2        9 eth1
	10.22.4.151     10.36.65.80     10.22.4.1             0      1        0 eth1
	10.22.4.151     10.36.65.84     10.22.4.1             0      0       13 eth1
	10.22.4.151     10.36.65.95     10.22.4.1             0      0       27 eth1
6、Use的含义：
	通过该路由发送的分组个数，使用ping命令，可以看到Use值的增加，如下：
	[root@localhost lib]# route -nC|grep -v lo
	Kernel IP routing cache
	Source          Destination     Gateway         Flags Metric Ref    Use Iface
	10.22.4.151     10.36.65.80     10.22.4.1             0      0       11 eth1
	10.22.4.151     10.36.65.80     10.22.4.1             0      1        0 eth1
7、Windows下的路由打印，如下：
	IPv4 路由表
===========================================================================
活动路由:
网络目标        网络掩码          网关       接口   跃点数
          0.0.0.0          0.0.0.0       10.36.65.1      10.36.65.80     20
       10.36.65.0    255.255.255.0            在链路上       10.36.65.80    276
      10.36.65.80  255.255.255.255       10.36.65.1      10.36.65.80     21
      10.36.65.80  255.255.255.255       10.36.65.2      10.36.65.80     43
     10.36.65.255  255.255.255.255            在链路上       10.36.65.80    276
        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    306
        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    306
  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    306
        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    306
        224.0.0.0        240.0.0.0            在链路上       10.36.65.80    276
  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    306
  255.255.255.255  255.255.255.255            在链路上       10.36.65.80    276
8、分别介绍如下：
	0.0.0.0				缺省路由
	10.36.65.0			直连网段的路由
	10.36.65.80			本地主机路由
	10.36.65.255		本地广播路由
	127.0.0.0			本地环路
	224.0.0.0			组播路由
	255.255.255.255		广播路由
	注意：组播路由和广播路由都是两条记录，是因为有环路127.0.0.1
@endverbatim
*/
路由打印;

/**
@verbatim
1、第1个字节是45，前面4个bit取值为4，表示IPv4，后面4个bit取值为5，表示IP头部长度是5
	特别注意：这里的单位是32bit，也就是说单位是4字节，5个单位也就是20字节，IP头部长度是确定的20字节。
	第2个字节是服务类型字段，3-4字节表示总长度，可表示的最大长度为65535，
	减去IP头长度[20字节]，减去TCP头长度[20字节固定长度+可选项]，就是有效数据的长度
2、接下来是16位标识，用于标识一个报文，可以看到是增长上去的。接下来3位标志是否分段，13位表示片的偏移
3、接下来8位生存时间TTL，8位协议字段，常用的协议有
	1[ICMP]Internet控制报文协议 6[TCP] 17[UDP] 45[IDRP]域内路由选择协议
	接下来16位表示IP头部校验和，注意：这里检验和只是对IP头部进行校验。
4、接下来32位（4个字节）表示源IP地址
5、接下来32位（4个字节）表示目的IP地址，总共20字节。
@endverbatim
*/
IP头部;


/** @} */

/** @} */
