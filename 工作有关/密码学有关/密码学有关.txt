/**
* @defgroup 工作有关
* @{
*/

/**
* @defgroup 密码学有关
* @{
*/

/**
@verbatim
1、对称密码，加解密的密钥相同，存在密钥配送问题。
2、解决密钥配送问题，使用非对称密码，公钥是公开的，用于加密，私钥自己保存，用于解密。
3、非对称密码，存在效率问题。因此，使用非对称的公钥，加密对称的密钥，对称密钥加密业务数据。这就是混合密码。
4、检查消息是否一致，也就是是否被篡改，使用单向散列函数，也叫消息摘要函数，hash函数。
5、单向散列函数可以辨别出"篡改"，但是不能辨别出"伪装"，需要确认是不是Alice发送的消息。
6、问题的原因是，单向散列函数，每个人计算的结果都一样，Bob无法确认是不是Alice发的
	解决办法是Alice和Bob共享一个密钥，其他人不知道，计算hash值的时候，这个密钥作为一个参数，
	必须知道密钥，才能计算出相同的hash值，这就是消息认证码。
7、相对于单向散列函数，消息认证码多了一个共享的密钥。
8、消息认证码存在问题，一个是共享密钥的配送问题，还存在一个问题，无法防止否认。
	Bob说Alice发了某个消息，Alice说没有发过，并且Alice说，Bob有密钥，也能生成这个消息。
9、如何解决这个问题？
	也就是说，只有Alice才能生成这个消息，其他人不能生成这个消息，但是可以验证这个消息是不是Alice生成的。
	参考非对称加密，其他人用公钥加密，只有我能使用私钥解密。反过来也是一样的，我要私钥加密，其他人使用公钥可以解密。
	只有我自己保存私钥，其他人能用公钥解密，就说明这个消息是我生成的，因为其他人没有私钥，是无法生成这个消息的。
	这就是数字签名。私钥加密生成签名，公钥解密验证签名。
10、正确使用数字签名，有一个前提，那就是验证签名的公钥，必须是正确的。如果这个公钥是伪造的，数字签名也会验证失败。
11、这就要解决公钥的合法性，公钥的获取需要一个可信任的第三方认证机构。
	第三方对Bob的公钥加上数字签名，发给Alice，Alice获取Bob的公钥。
	可信的第三方也就意味着，Alice已知Trent合法的公钥，通过Trent来获取Bob的公钥。
12、具体流程是：
	a、Bob向Trent注册自己的公钥，这个环节是人工保证可靠性，Trent会通过电话、邮箱、或者面对面，和Bob确认。
	b、Alice已知Trent的公钥，向Trent请求Bob的公钥，Trent为了证明是自己发送的消息，会对Bob的公钥，加上数字签名，发给Alice
	c、Bob的公钥，加上Trent的数字签名，就是证书。通过Trent获取到Bob的公钥。
	d、有了Bob的公钥，二者就可以加密通信了。
	注意：这里传输的公钥，不需要加密，只是保证Alice能够获取合法的公钥。
@endverbatim
*/
密码学概述;

/**
@verbatim	
1、Blowfish算法
	Blowfish算法是一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。
	32位处理器诞生后，Blowfish算法因其在加密速度上超越了DES而引起人们的关注。
	Blowfish算法具有加密速度快、紧凑、密钥长度可变、可免费使用等特点，已被广泛使用于众多加密软件。
@endverbatim
*/
Blowfish;

/**
@verbatim	
1、Message Digest Algorithm MD5（中文名为消息摘要算法第五版）为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。
2、MD5算法具有以下特点：
	压缩性：任意长度的数据，算出的MD5值长度都是固定的。
	容易计算：从原数据计算出MD5值很容易。
	抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
	强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
3、MD5是不可逆加密，不涉及到解密，也无法解密，因此没有秘钥的概念。
	MD5相同的明文，会得到相同的密文，存在风险，使用彩虹表可以破解，彩虹表是只拿到密文，就可以破解。
@endverbatim
*/
MD5;


/**
@verbatim	
1、安全哈希算法（Secure Hash Algorithm）对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。
	在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 SHA1有如下特性：
	不可以从消息摘要中复原信息；
	两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。
2、SHA1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者。
@endverbatim
*/
SHA1;

/**
@verbatim	
1、一般的加密算法，使用同一个秘钥，相同的明文加密得到相同的密文。
	MD5等不可逆的hash算法，不涉及秘钥，相同的明文也会得到相同的密文。
2、相同明文得到相同密文，存在风险，特别是明文的集合空间比较小的场景。考虑下面的场景：
	a、数据库保存用户的登录密码，密码是加密保存的，用户张三访问到数据库，虽然密码是密文，但是张三看到李四的密文和自己的密文相同，
		推断李四的密码和自己的密码相同，然后就可以使用李四的账号登录。
	b、考虑数据库保存员工的绩效考核，有优秀、良好、合格、不合格，密文存储，不知道每个员工的绩效，但是考虑到绩效正态分布的特点，
		推断出每个明文对应的密文。
	c、还有一种情况，只拿到密文，但是明文的集合空间比较小，通过构建彩虹表，也可以破解。
3、怎么解决上面的问题？
	加盐，也就是对明文添加一些随机值，然后再加密。
	一方面，相同的明文得到不同的密文，解决a、b两种情况，另一方面，添加随机值，大大增加了加密数据的集合空间，破解难度非常大。		
4、对于我们的项目，需要权衡考虑。
	这里存在一种假设，那就是第三方只拿到加密后的数据库，并且不知道某一个明文对应的密文。
	这里涉及到几种场景：
	a、预期支持同态运算，比如add、serach，不能加盐，也就是不添加RND洋葱层。
	b、前期不确定，开始的时候，添加RND洋葱层，当涉及到同态运算的时候，需要剥掉洋葱层，并且剥掉就剥掉了。
	c、预期不支持同态运算，也就是不作为查询条件，添加RND洋葱层，不涉及剥洋葱。
5、现在考虑，是否足够安全，假设第三方只拿到加密后的数据库。
	为了支持同态运算，不能加盐，也就是没有RND洋葱层，存在一定的风险，但是风险可控。a、b两种情况，是可以避免的。
	c情况彩虹表只是对于hash算法有效，对于有些算法不能破解，比如RSA。
	特别核心的数据，只是作为查询的结果，建议使用RND层。	
@endverbatim
*/
数据加密为什么要加盐;


/** @} */

/** @} */
