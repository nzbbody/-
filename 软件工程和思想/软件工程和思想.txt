/**
 * Copyright (c) 2015~2016, Andy Niu All rights reserved.
 * \file		软件工程和思想.txt
 * \brief		软件工程和思想
 * \author		牛自宾
 * \date		2015年7月5日
 * \note		软件工程和思想帮助文档
 */

/**
* @defgroup 软件工程和思想
* @{
*/


/**
@verbatim
1、透过现象看本质，机制与策略到底是什么？为什么要将机制与策略分离？
2、反映在系统设计上，机制是目标功能，策略是实现方法，也可以认为是接口与实现。
3、反映在管理上，领导负责机制，员工负责策略，也就是说，领导决定做什么，怎么做是员工的事情。
4、为什么要将机制与策略分离？
	假如不分离，会出现什么问题？考虑下面的场景，要完成排序的功能，如果接口和实现捆绑在一起，并使用冒泡排序完成。
	那么问题来了，我想换一种排序算法，比如快速排序，接口和实现都要替换。怎么解决这个问题？
	也就是机制与策略分离，提供一个排序接口，继承接口，提供不同的实现，这也就是策略模式。
	Context关联一个抽象的策略（也就是接口），用不同的具体策略初始化抽象策略，就能调用具体策略的处理流程。
@endverbatim
@see
*/
机制与策略;


/**
@verbatim
软件的本质就是封装。根据已知的实现，对这些实现封装，对外暴露接口。操作系统对硬件封装，对外暴露接口。
高级编程语言对操作系统进行封装，对外暴露接口。应用软件对高级语言封装，对外暴露接口，很多是人机接口，提供UI界面。
@endverbatim
@see
*/
软件的本质就是封装;



/**
@verbatim
所有的软件，无非是增删改查和数据的可视化。Google也就是做了一个查，只不过查的对象是整个互联网内容，
互联网上的用户进行增删改操作。淘宝也就是对商品的增删改查。
@endverbatim
@see
*/
软件的功能就是增删改查和数据可视化;


/**
@verbatim
可以把软件的运行看成做一件事，比如做菜。做菜需要菜谱，菜谱列出了需要哪些原料和操作步骤，
人按照操作步骤，加工数据。菜谱就是程序，原料就是数据，操作步骤就是程序的控制流程，人就是CPU，
人做菜就是CPU执行程序，就是进程。
@endverbatim
@see
*/
软件的运行;


/**
@verbatim
概要设计过程：确定边界，划模块，定接口，理流程。分别如下：
1、确定边界：确定边界后，才能明确与外部哪些实体交互，交互需要确定：通信方式是串口还是网络，
消息的大小，消息的格式，消息是同步还是异步。
2、划模块：模块之间有竖直关系和水平关系，比如MVVM模式可以认为是竖直关系，从外部的界面到内部的数据。
水平关系比如：接受消息，处理消息，转发消息。
3、定接口：模块可以认为是一个IPO（Input-Process-Output）控件，概设的时候，模块是一个黑盒，对外的接口要尽量小。
4、理流程：使用时序图，说明对于一个功能，若干模块是如何协作完成的。
@endverbatim
@see
*/
概要设计;

/**
@verbatim
1、所有工具都是为了人类解决问题的，这也是人类发明工具的动力。
2、通用型的好处在于适用较大的范围，缺点是对于特定的场景会退化。通用性意味着冗余、笨重、效率低下，
	因为通用性要考虑不同的情况，这些情况要均衡地处理。
3、针对性在特定场景下很好地满足用户需求，如果用户需求经常变化，就很难处理。
4、通用性和针对性解决不同的问题，也就是有不同的应用场景。举例来说，市场上有万能锅，能煮饭，能炒菜，能炖汤，
	但是它的效果肯定比不过专业的炖汤锅（注：同等价位）。如果家里有多种用处，煮饭，炒菜，炖汤，那就要买万能锅。
	如果只是拿来炖汤，就要买专业的炖汤锅。
5、这就能解释，已经存在很多成熟的开源库，为什么有些公司还要自己重新开发？
	这里存在两个问题：
	开源的网络库不能很好地满足自己特定的需求。
	功能丰富的开源库，代码量很大，不吃透就使用，有很大的风险。如果全部吃透，人力物力的开销可能比自己实现还要大很多。
@endverbatim
@see
*/
通用性和针对性;

/**
@verbatim
1、《精通正则表达式》，孟岩作序：Bill Joy 软件世界的爱迪生，这家伙发明了BSD，TCP/IP，csh，vi和NFS，是SUN的首席科学家，
	现在已离职，2003年离职的时候，SUN股票应声下跌3.2%
2、Bill Joy曾经调侃说，在计算机领域中，缓存是唯一称得上伟大的思想，其他的发明和技术不过是在不同场景下应用这一思想而已。
3、典型的场景应用：
	Mysql的缓存
	线程池
	对象池
	客户端频繁查询某些信息，这些信息保存到内存中，避免重复读取数据库。
		注意：保证内存和数据库的信息同步，信息变化需要从数据库读取，并更新内存。
	插入数据库，缓存起来批量写入。
@endverbatim
@see
*/
缓存;


/**
@verbatim
1、每个模块都是消息处理单元，外部线程往这个模块里面Push消息，这个模块启动一个线程，用来处理消息。
	启动线程while死循环，主动轮巡检查消息队列，然后处理消息。这就是流程驱动。
2、有没有更好的处理办法呢？
	也就是，外部线程Push进去一个消息，回调上来一次，然后处理消息。这就是事件驱动。
	给人感觉就是，这里触发一下，从另外一个地方回调上来处理消息。
3、怎么实现事件驱动呢？
	第一种方法：把while死循环，下沉到底层（也就是底层启动一个线程，进行主动轮巡），向底层注册回调方法。
	检测到一个消息，从底层回调上来。也就是说，事件驱动是对流程驱动的封装，while循环下沉到底层，底层进行主动轮巡。
	
	第二种方法：使用PV操作，当前线程底层while死循环，每次进行P操作。
	其他线程Push消息的时候，内部调用notify一下底层（也就是V操作），然后底层回调上来。
	也就是，任何模块向当前模块发送一个消息，当前模块都回调上来。
@endverbatim
@see
*/
流程驱动和事件驱动;



/** @} */
